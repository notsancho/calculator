'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function curry(f) {
  var arity = f.length;

  var g = function g(oldArgs) {
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var newArgs = oldArgs.concat(args.length > 0 ? args : undefined); // If we have enough args, then apply the function.

      return newArgs.length >= arity ? f.apply(undefined, newArgs) : g(newArgs);
    };
  };

  return arity <= 1 ? f : g([]);
}

/**
 * Returns the sum of two numbers.
 *
 * @param {Number} a The first number.
 * @param {Number} b The second number.
 * @returns {Number} The result of `b + a`.
 */

function add(a, b) {
  return b + a;
}
var add$1 = curry(add);

/**
 * Returns a function that always returns the same value, regardless of the
 * arguments.
 *
 * @param c A value.
 * @returns {Function} A function that always returns the value `c`.
 *
 * @example
 *
 * F.always(1)() // 1
 *
 */
function always(c) {
  return function () {
    return c;
  };
}

/**
 * Branches execution based on a predicate function.
 *
 * If `p(a)` is true then `f` is applied to `a`, otherwise `g` is
 * applied to `a`.
 *
 * @param {Function} p A predicate function.
 * @param {Function} f A function.
 * @param {Function} g A function.
 * @param a The value to apply to the predicate function `p`.
 * @returns The result.
 *
 * @example
 *
 * function big (a) { return a + ' is a big number' }
 * function small (a) { return a + ' is a small number' }
 * var f = F.branch(F.gt(10), big, small)
 * f(10) // small number
 * f(11) // big number
 */

function branch(p, f, g, a) {
  return p(a) ? f(a) : g(a);
}
var branch$1 = curry(branch);

/**
 * The identity function.
 *
 * @param a A value.
 * @returns The value `a`.
 *
 * @example
 *
 * F.id(1) // 1
 */
function id(a) {
  return a;
}

/**
 * Returns true if `as` is a string or an array of strings.
 *
 * @private
 */
function isString(as) {
  return typeof as === 'string';
}

/**
 * Flattens the list of `as`.
 *
 * @private
 */
function flatten(as) {
  return as.reduce(function (a, b) {
    return a.concat(b);
  }, []);
}

function extend(target, objects) {
  objects.forEach(function (object) {
    Object.getOwnPropertyNames(object).forEach(function (property) {
      target[property] = object[property];
    });
  });
  return target;
}
var slice = Array.prototype.slice;

/**
 * Converts a function to a variadic function.
 *
 * The last named parameter will be given an array of arguments.
 *
 * @param {Function} f A function.
 * @returns {Function} A function that wraps the function `f` to accept any
 * number of arguments.
 *
 * @example
 *
 * function f (head, tail) { ... }
 * F.variadic(f)(1, 2, 3) // f(1, [2, 3])
 */

function variadic(f) {
  var _this = this;

  var arity = f.length;

  if (arity < 1) {
    return f;
  } else if (arity === 1) {
    return function () {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var newArgs = args.length === 1 ? flatten(args) : args;
      return f.call(_this, newArgs);
    };
  } else {
    return function () {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var numMissingArgs = Math.max(arity - args.length - 1, 0);
      var missingArgs = new Array(numMissingArgs);
      var namedArgs = slice.call(args, 0, arity - 1);
      var variadicArgs = slice.call(args, f.length - 1);
      return f.apply(_this, namedArgs.concat(missingArgs).concat([variadicArgs]));
    };
  }
}

/**
 * Composes a list of functions.
 *
 * @function
 * @param {Array} fs A list of functions.
 * @returns {Function} A function that is the composition of the list of
 * functions `fs`.
 *
 * @example
 *
 * F.compose(f, g, h)(a) // f(g(h(a)))
 */

var compose = variadic(function (fs) {
  return function (a) {
    return fs.reduceRight(function (a, f) {
      return f(a);
    }, a);
  };
});

/**
 * Appends a value to a list.
 *
 * @param a A value.
 * @param {Array|String} bs A list.
 * @returns {Array|String} A list that contains the value `a` appended to the
 * list of `bs`.
 *
 * @example
 *
 * F.append(3, [1, 2]) // [1, 2, 3]
 * F.append('o', 'fo') // 'foo'
 */

function append(a, bs) {
  return isString(bs) ? bs + a : bs.concat([a]);
}
var append$1 = curry(append);

/**
 * Swaps the order of the arguments to a function.
 *
 * @param {Function} f A function.
 * @param a A value.
 * @param b A value.
 * @returns {Function} The result of applying the function `f` to the values
 * `b` and `a`.
 *
 * @example
 *
 * function f (a, b) { ... }
 * var g = F.flip(f)
 * g(1, 2) // f(2, 1)
 */

function flip(f, a, b) {
  return f(b, a);
}
var flip$1 = curry(flip);

/**
 * Converts the list of `as` to an array.
 *
 * @private
 */

function toArray(as) {
  return isString(as) ? as.split('') : as;
}

/**
 * Returns a list that contains the elements in the list of `as` concatenated
 * with the starting value `s`.
 *
 * @private
 */

function concatWith(s, as) {
  return toArray(flatten(as)).reduce(flip$1(append$1), s);
}

/**
 * Returns true if `as` is an array.
 *
 * @private
 */
function isArray(as) {
  return Array.isArray(as);
}

/**
 * Returns true if the list of `as` is an array of strings, false otherwise.
 *
 * @private
 */

function isArrayOfStrings(as) {
  return isArray(as) && as.length > 0 && as.reduce(function (a, b) {
    return a && isString(b);
  }, true);
}

/**
 * Returns an empty monoid of `as`.
 *
 * @private
 */

function mempty(as) {
  return isString(as) || isArrayOfStrings(as) ? '' : [];
}

/**
 * Concatenates multiple lists into a single list.
 *
 * @function
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the concatenated elements in
 * the list of `as`.
 *
 * @example
 *
 * F.concat([1], [2, 3], [4, 5, 6]) // [1, 2, 3, 4, 5, 6]
 * F.concat('f', 'oo', 'bar') // 'foobar'
 */

var concat = variadic(function (as) {
  return concatWith(mempty(as), as);
});

/**
 * Flattens any strings in the list of `as`.
 *
 * @private
 */

function flattenStrings(as) {
  if (isArrayOfStrings(as)) {
    return concat(as);
  } else {
    if (isArray(as)) {
      return as.map(flattenStrings);
    } else {
      return as;
    }
  }
}

/**
 * Maps a function over a list and concatenates the results.
 *
 * @param {Function} f A function that returns a list.
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the elements in the list of
 * `as`, mapped with the function `f`, and concatenated together.
 *
 * @example
 *
 * F.concatMap(a => [a, 0], [1, 2, 3]) // [1, 0, 2, 0, 3, 0]
 * F.concatMap(a => [a, '-'], 'foo') // 'f-o-o-'
 */

function concatMap(f, as) {
  var bs = toArray(as).map(compose(flattenStrings, f));
  var cs = bs.length > 0 ? bs : as;
  return concatWith(mempty(cs), bs);
}
var concatMap$1 = curry(concatMap);

/**
 * Filters a list using a predicate function.
 *
 * @param {Function} p A predicate function.
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains only the elements in the list
 * of `as` that satisfy the predicate function `p`.
 *
 * @example
 *
 * F.filter(F.gt(1), [1, 2, 3]) // [2, 3]
 * F.filter(F.eq('o'), 'foo') // 'oo'
 */

function filter(p, as) {
  var f = branch$1(p, id, always(''));
  return isString(as) ? concatMap(f, as) : as.filter(p);
}
var filter$1 = curry(filter);

/**
 * Determines whether all elements in a list satisfy a predicate function.
 *
 * @param {Function} p A predicate function.
 * @param {Array|String} as A list.
 * @returns {Boolean} `true` if all elements of the list of `as` satisfy the
 * predicate, `false` otherwise.
 *
 * @example
 *
 * F.all(F.gt(1), [1, 2, 3]) // false
 * F.all(F.gt(1), [2, 3]) // true
 * F.all(F.gt(1), [3]) // true
 *
 * F.all(F.eq('o'), 'foo') // false
 * F.all(F.eq('o'), 'oo') // true
 * F.all(F.eq('o'), 'o') // true
 */

function all(p, as) {
  return filter(p, as).length === as.length;
}
var all$1 = curry(all);

/**
 * Returns the logical AND of two values.
 *
 * @param a The first value.
 * @param b The second value.
 * @returns {Boolean} The result of `b && a`.
 *
 * @example
 *
 * F.and(true, true) // true
 * F.and(0, 1) // false
 * F.and('', 'foo') // false
 */

function and(a, b) {
  return !!(b && a);
}
var and$1 = curry(and);

/**
 * Determines whether any elements in a list satisfy a predicate function.
 *
 * @param {Function} p A predicate function.
 * @param {Array|String} as A list.
 * @returns {Boolean} `true` if any elements in the list of `as` satisfy the predicate
 *
 * @example
 *
 * F.any(F.gt(1), [1, 2, 3]) // true
 * F.any(F.gt(1), [1, 2]) // true
 * F.any(F.gt(1), [1]) // false
 *
 * F.any(F.eq('o'), 'foo') // true
 * F.any(F.eq('o'), 'fo') // true
 * F.any(F.eq('o'), 'f') // false
 * function `p`, `false` otherwise.
 */

function any(p, as) {
  return filter(p, as).length > 0;
}
var any$1 = curry(any);

/**
 * Applies a function to a value.
 *
 * @param {Function} f A function.
 * @param a A value.
 * @returns The result of `f(a)`.
 *
 * @example
 *
 * function sayHi (a) { return ['Hi', a, '!'].join(' ') }
 * f.apply(sayHi, 'jane') // Hi Jane!
 */

function apply(f, a) {
  return f(a);
}
var apply$1 = curry(apply);

/**
 * Applies a function to two values.
 *
 * @param {Function} f A function.
 * @param a A value.
 * @param b A value.
 * @returns The result of `f(a, b)`.
 *
 * @example
 *
 * function sayHi (a, b) { return ['Hi', a, b, '!'].join(' ') }
 * F.apply2(sayHi, 'Jane', 'Appleseed') // Hi Jane Appleseed!
 */

function apply2(f, a, b) {
  return f(a, b);
}
var apply2$1 = curry(apply2);

/**
 * Applies a function to three values.
 *
 * @param {Function} f A function.
 * @param a A value.
 * @param b A value.
 * @param c A value.
 * @returns The result of `f(a, b, c)`.
 *
 * @example
 *
 * function sayHi (a, b, c) { return ['Hi', a, b, c, '!'].join(' ') }
 * F.apply3(sayHi, 'Ms', 'Jane', 'Appleseed') // Hi Ms Jane Appleseed!
 */

function apply3(f, a, b, c) {
  return f(a, b, c);
}
var apply3$1 = curry(apply3);

/**
 * Applies a method to a value.
 *
 * @param {String} k A method name.
 * @param a A value.
 * @param {Object} o An object.
 * @returns The result of the method `k` of object `o` applied to the value
 * `a`.
 *
 * @example
 *
 * var person = { sayHi: a => ['Hi', a, '!'].join(' ') }
 * F.applyMethod('sayHi', 'Jane', person) // Hi Jane!
 */

function applyMethod(k, a, o) {
  return o[k](a);
}
var applyMethod$1 = curry(applyMethod);

/**
 * Applies a method to two values.
 *
 * @param {String} k A method name.
 * @param a A value.
 * @param b A value.
 * @param {Object} o An object.
 * @returns The result of the method `k` of object `o` applied to the values
 *
 * @example
 *
 * var person = { sayHi: (a, b) => ['Hi', a, b, '!'].join(' ') }
 * F.applyMethod2('sayHi', 'Jane', 'Appleseed', person) // Hi Jane Appleseed!
 * `a` and `b`.
 */

function applyMethod2(k, a, b, o) {
  return o[k](a, b);
}
var applyMethod2$1 = curry(applyMethod2);

/**
 * Applies a method to three values.
 *
 * @param {String} k A method name.
 * @param a A value.
 * @param b A value.
 * @param c A value.
 * @param {Object} o An object.
 * @returns The result of the method `k` of object `o` applied to the values
 * `a`, `b`, and `c`.
 *
 * @example
 *
 * var person = { sayHi: (a, b, c) => ['Hi', a, b, c, '!'].join(' ') }
 * F.applyMethod3('sayHi', 'Ms', 'Jane', 'Appleseed', person) // Hi Ms Jane Appleseed!
 */

function applyMethod3(k, a, b, c, o) {
  return o[k](a, b, c);
}
var applyMethod3$1 = curry(applyMethod3);

/**
 * Applies a function to a value. This is similar to `apply`, however the
 * order of the arguments is flipped.
 *
 * @param a A value.
 * @param {Function} f A function.
 * @returns The result of `f(a)`.
 *
 * @example
 *
 * function sayHi (a) { return ['Hi', a, '!'].join(' ') }
 * F.applyRight('Jane', sayHi) // Hi Jane!
 */

function applyRight(a, f) {
  return f(a);
}
var applyRight$1 = curry(applyRight);

/**
 * Creates a new array.
 *
 * @param {Number} n The length of the array.
 * @returns {Array} An array of length `n`.
 *
 * @example
 *
 * F.array(3) // [undefined, undefined, undefined]
 */
function array(n) {
  return Array.apply(null, Array(n));
}

/**
 * Determines whether a number is between two numbers.
 *
 * @param {Number} a The first number.
 * @param {Number} b The second number.
 * @param {Number} n The number to test.
 * @returns {Number} `true` if the number `n` is between the numbers `a` and
 * `b` (i.e. a <= n <= b), `false` otherwise.
 *
 */

function between(a, b, n) {
  return a <= n && b >= n;
}
var between$1 = curry(between);

/**
 * Converts a function of any arity to a binary function.
 *
 * @param {Function} f A function.
 * @returns {Function} A function that wraps the function `f` to accept only
 * two arguments.
 *
 * @example
 *
 * function f (a, b) { ... }
 * const g = F.binary(f)
 * g(1, 2, 3) // f(1, 2)
 */

function binary(f) {
  return f.length === 2 ? f : apply2$1(f);
}

/**
 * Determines if a list is empty.
 *
 * @param {Array|String} as A list.
 * @returns {Boolean} `true` if the list of `as` is empty, `false` otherwise.
 *
 * @example
 *
 * F.empty([]) // true
 * F.empty([1, 2, 3]) // false
 *
 * F.empty('') // true
 * F.empty('foo') // false
 */
function empty(as) {
  return as.length === 0;
}

/**
 * Gets the first element in a list.
 *
 * @param {Array|String} as A list or string.
 * @returns The first element in the list of `as`, or `undefined` if the list
 * is empty.
 *
 * @example
 *
 * F.head([1, 2, 3]) // 1
 * F.head('foo') // 'f'
 */
function head(as) {
  return as[0];
}

/**
 * Creates a new ordered pair.
 *
 * @param a A value.
 * @param b A value.
 * @returns {Array} An ordered pair with the values `a` and `b`.
 *
 * @example
 *
 * F.pair(1, 2) // [1, 2]
 * F.pair('a', 'b') // ['a', 'b']
 */

function pair(a, b) {
  return [a, b];
}
var pair$1 = curry(pair);

/**
 * Get the elements after the first element in a list.
 *
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the elements after the first
 * element in the list of `as`.
 *
 * @example
 *
 * F.tail([1, 2, 3]) // [2, 3]
 * F.tail('foo') // 'oo'
 */
function tail(as) {
  return as.slice(1);
}

/**
 * Maps a function over a list.
 *
 * @param {Function} f A function.
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the elements in the list of
 * `as` mapped with the function `f`.
 *
 * @example
 *
 * F.map(F.inc, [1, 2, 3]) // [2, 3, 4]
 * F.map(F.toUpper, 'foo') // ['F', 'O', 'O']
 */

function map(f, as) {
  return toArray(as).map(f);
}
var map$1 = curry(map);

/**
 * Calculates the cartesian product of two lists.
 *
 * @param {Array|String} as A list.
 * @param {Array|String} bs A list.
 * @returns {Array} Returns a list that contains all the ordered pairs `[a, b]`
 * in the lists of `as` and `bs`.
 *
 * @example
 *
 * F.cartesian([1, 2], [3, 4]) // [[1, 3], [1, 4], [2, 3], [2, 4]]
 * F.cartesian('ab', 'cd') // [['a', 'c'], ['a', 'd'], ['b', 'c'], ['b', 'd']]
 */

function cartesian(as, bs) {
  return empty(as) ? [] : concat(map(pair$1(head(as)), bs), cartesian(tail(as), bs));
}
var cartesian$1 = curry(cartesian);

/**
 * Determines the largest of two numbers.
 *
 * @param {Number} a A number.
 * @param {Number} b A number.
 * @returns {Number} The largest of the numbers `a` and `b`.
 */

function max(a, b) {
  return b > a ? b : a;
}
var max$1 = curry(max);

/**
 * Determines the smallest of two numbers.
 *
 * @param {Number} a A number.
 * @param {Number} b A number.
 * @returns {Number} The smallest of the numbers `a` and `b`.
 */

function min(a, b) {
  return a > b ? b : a;
}
var min$1 = curry(min);

/**
 * Clamps a number between two values.
 *
 * @param {Number} a A number.
 * @param {Number} b A number.
 * @param {Number} n A number.
 * @returns {Number} The result of clamping the number `n` between the numbers
 * `a` and `b` (i.e. `a <= n <= b`).
 */

function clamp(a, b, n) {
  return max(a, min(n, b));
}
var clamp$1 = curry(clamp);

/**
 * Compares two values using natural ordering.
 *
 * This function compares two elements, `a` and `b`. If `a` is greater than
 * `b`, then it returns `1`. If `a` is less than `b`, then it returns `-1`. If
 * both elements are equal, then it returns `0`.
 *
 * @param a A value.
 * @param b A value.
 * @returns {Number} The result.
 *
 * @example
 *
 * F.compare(2, 1) // 1
 * F.compare(1, 2) // -1
 * F.compare(2, 2) // 0
 */

function compare(a, b) {
  if (a > b) {
    return 1;
  } else if (a < b) {
    return -1;
  } else {
    return 0;
  }
}
var compare$1 = curry(compare);

/**
 * Creates a copy of one or more objects.
 *
 * Properties with the same key will take precedence from right to left. The
 * copy will have the *same* prototype as the *first* object in the list.
 *
 * @function
 * @param {Array} os A list of objects.
 * @returns {Object} A copy of the objects in the list of `os`.
 *
 * @example
 *
 * var person = { name: 'Jane', age: 20, city: 'Melbourne' }
 * F.copy(person, { name: 'Steve' }) // { name: 'Steve', age: 20, city: 'Melbourne' }
 */

var copy = variadic(function (o, ps) {
  return extend(Object.create(Object.getPrototypeOf(o)), [o].concat(ps));
});

/**
 * Decrements a number.
 *
 * @param {Number} a A number.
 * @returns {Number} The result of `a - 1`.
 */
function dec(a) {
  return a - 1;
}

/**
 * Determines whether two values are equal.
 *
 * @param a The first value.
 * @param b The second value.
 * @returns {Boolean} `true` if the value `a` is strictly not equal (`===`) to
 * the value `b`, false otherwise.
 *
 * @example
 *
 * F.eq(1, 1) // true
 * F.eq(1, 2) // false
 */

function eq(a, b) {
  return b === a;
}
var eq$1 = curry(eq);

/**
 * Prepends a value to a list.
 *
 * @param a A value.
 * @param {Array|String} bs A list.
 * @returns {Array|String} A list that contains the value `a` prepended to the
 * list of `bs`.
 *
 * @example
 *
 * F.prepend(1, [2, 3]) // [1, 2, 3]
 * F.prepend('f', 'oo') // 'foo'
 */

function prepend(a, bs) {
  return isString(bs) ? a + bs : [a].concat(bs);
}
var prepend$1 = curry(prepend);

/**
 * Removes duplicate elements from a list using a comparator function.
 *
 * The comparator function compares two elements, `a` and `b`. If the elements
 * are both considered to equal, then the comparator function should return
 * `true`. Otherwise it should return `false`.
 *
 * @param {Function} f A comparator function.
 * @param {Array|String} as A list.
 * @returns {Array|String} A list with all duplicate elements removed from the
 * list of `bs`.
 *
 * @example
 *
 * F.nubBy((a, b) => a === b, [1, 2, 2, 3, 3, 3]) // [1, 2, 3]
 * F.nubBy((a, b) => a === b, 'abbccc') // 'abc'
 */

function nubBy(f, as) {
  var a = head(as);
  return empty(as) ? mempty(as) : prepend(a, nubBy(f, filter(function (b) {
    return !f(a, b);
  }, tail(as))));
}
var nubBy$1 = curry(nubBy);

/**
 * Removes duplicate elements from a list.
 *
 * This is a special case of the `nubBy` function where the elements are compared
 * using the strict equality `===` operator.
 *
 * @param {Array|String} as A list.
 * @returns {Array|String} A list with all duplicate elements removed from the list of `as`.
 *
 * @example
 *
 * F.nub([1, 2, 2, 3, 3, 3]) // [1, 2, 3]
 * F.nub('abbccc') // 'abc'
 *
 */

var nub = nubBy$1(eq$1);

/**
 * Removes the first occurance of an element from a list using a comparator
 * function.
 *
 * The comparator function `f` compares two elements, `a` and `b`. If the
 * elements are both considered to equal, then the comparator function should
 * return `true`. Otherwise it should return `false`.
 *
 * @param {Function} f A comparator function.
 * @param a A value.
 * @param {Array|String} bs A list.
 * @returns {Array|String} A list with the first occurance of the element `a`
 * removed from the list of `bs`.
 *
 * @example
 *
 * F.removeBy((a, b) => a === b, 2, [1, 2, 3]) // [1, 3]
 * F.removeBy((a, b) => a === b, 'f', 'foo') // 'oo'
 */

function removeBy(f, a, bs_) {
  var b = head(bs_);
  var bs = tail(bs_);
  return empty(bs_) ? mempty(bs_) : f(a, b) ? bs : prepend(b, removeBy(f, a, bs));
}
var removeBy$1 = curry(removeBy);

/**
 * Folds a list from left-to-right with a function.
 *
 * @param {Function} f A binary function.
 * @param s A starting value.
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the elements in the list of
 * `as` folded left-to-right with the binary function `f` and starting value
 * `s`.
 *
 * @example
 *
 * F.fold(F.flip(F.prepend), [], [1, 2, 3]) // [3, 2, 1]
 * F.fold(F.flip(F.prepend), '', 'foo') // 'oof'
 */

function fold(f, s, as) {
  return toArray(as).reduce(f, s);
}
var fold$1 = curry(fold);

/**
 * Calculates the difference of two lists.
 *
 * The comparator function `f` compares two elements, `a` and `b`. If the
 * elements are considered to be equal, then the comparator function should
 * return `true`. Otherwise it should return `false`.
 *
 * @param {Function} f A comparator function.
 * @param {Array|String} as A list.
 * @param {Array|String} bs A list.
 * @returns {Array|String} A list that contains the difference of the elements
 * in the lists of `as` and `bs`.
 *
 *
 * @example
 *
 * F.differenceBy((a, b) => a === b, [1, 2, 3], [2, 3, 4]) // [1]
 * F.differenceBy((a, b) => a === b, 'hello', 'world') // 'he'
 */

function differenceBy(f, as, bs) {
  return fold(flip$1(removeBy$1(f)), nub(as), nub(bs));
}
var differenceBy$1 = curry(differenceBy);

/**
 * Calculates the difference of two lists.
 *
 * This is a special case of the `differenceBy` function where the elements are
 * compared using the strict equality `===` operator.
 *
 * @function
 * @param {Array|String} as A list.
 * @param {Array|String} bs A list.
 * @returns {Array|String} A list that contains the difference of the elements
 * in the lists of `as` and `bs`.
 *
 * @example
 *
 * F.difference([1, 2, 3], [2, 3, 4]) // [1]
 * F.difference('hello', 'world') // 'he'
 */

var difference = differenceBy$1(eq$1);

/**
 * Returns the division of two numbers.
 *
 * @param {Number} a The first number.
 * @param {Number} b The second number.
 * @returns {Number} The result of `b / a`.
 */

function div(a, b) {
  return b / a;
}
var div$1 = curry(div);

/**
 * Drops a number of elements from the start of a list.
 *
 * @param {Number} n The number of elements to drop.
 * @param {Array|String} as A list.
 * @returns {Array|String} The result after dropping `n` elements from the list
 * of `as`.
 *
 * @example
 *
 * F.drop(2, [1, 2, 3]) // [3]
 * F.drop(2, 'foo') // 'o'
 */

function drop(n, as) {
  var s = isString(as) ? '' : [];
  var m = as.length;

  for (var i = n; i < m; i++) {
    s = s.concat(as[i]);
  }

  return s;
}
var drop$1 = curry(drop);

/**
 * Drops elements from the start of a list using a predicate function.
 *
 * @param {Function} p A predicate function.
 * @param {Array|String} as A list.
 * @returns {Array|String} The result after dropping elements from the list of
 * `as` while the predicate function `p` is satisfied.
 *
 * @example
 *
 * F.dropWhile(F.lt(3), [1, 2, 3]) // [3]
 * F.dropWhile(F.neq(o), 'foo') // 'oo'
 */

function dropWhile(p, as) {
  var s = isString(as) ? '' : [];
  var m = as.length;
  var n = 0;

  while (n < m && p(as[n])) {
    n++;
  }

  for (var i = n; i < m; i++) {
    s = s.concat(as[i]);
  }

  return s;
}
var dropWhile$1 = curry(dropWhile);

/**
 * Determines if a value is present in a list.
 *
 * @param a A value.
 * @param {Array|String} as A list.
 * @returns {Boolean} `true` if the list of `as` contains the value `a`,
 * `false` otherwise.
 *
 * @example
 *
 * F.elem(0, [1, 2, 3]) // false
 * F.elem(1, [1, 2, 3]) // true
 *
 * F.elem('a', 'foo') // false
 * F.elem('o', 'foo') // true
 */

function elem(a, as) {
  return as.indexOf(a) >= 0;
}
var elem$1 = curry(elem);

/**
 * Gets the index of the first occurance of a value in a list.
 *
 * @param a A value.
 * @param {Array|String} as A list.
 * @returns {Number} The index of the first occurance of the value `a` in the
 * list of `as`, or `undefined` if no value was found.
 *
 * @example
 *
 * F.elemIndex(0, [1, 2, 3]) // undefined
 * F.elemIndex(1, [1, 2, 3]) // 0
 *
 * F.elemIndex('a', 'foo') // undefined
 * F.elemIndex('o', 'foo') // 1
 */

function elemIndex(a, as) {
  var i = as.indexOf(a);
  return i >= 0 ? i : undefined;
}
var elemIndex$1 = curry(elemIndex);

/**
 * Finds the indices of all the values in a list that satisfy a predicate
 * function.
 *
 * @param {Function} p A predicate function.
 * @param {Array|String} as A list.
 * @returns {Array} The indices of the values in the list of `as` that satisfy
 * the predicate function `p`.
 *
 * @example
 *
 * F.findIndices(F.gt(1), []) // []
 * F.findIndices(F.gt(1), [1, 2, 3]) // [1, 2]
 *
 * F.findIndices(F.eq('o'), '') // []
 * F.findIndices(F.eq('o'), 'foo') // [1, 2]
 */

function findIndices(p, as) {
  var s = [];
  var n = as.length;

  for (var i = 0; i < n; i++) {
    if (p(as[i])) {
      s.push(i);
    }
  }

  return s;
}
var findIndices$1 = curry(findIndices);

/**
 * Gets the indices of all occurances of a value in a list.
 *
 * @param a A value.
 * @param {Array|String} as A list.
 * @returns {Array} The indices of all occurances of the value `a` in the list
 * of `as`.
 *
 * @example
 *
 * F.elemIndices(0, [1, 2, 3]) // []
 * F.elemIndices(1, [1, 2, 3]) // [0]
 *
 * F.elemIndices('a', 'foo') // []
 * F.elemIndices('o', 'foo') // [1, 2]
 */

function elemIndices(a, as) {
  return findIndices(eq$1(a), as);
}
var elemIndices$1 = curry(elemIndices);

/**
 * Determines whether a number is even.
 *
 * @param {Number} a A number.
 * @returns {Boolean} `true` if the number `a` is even, false otherwise.
 */
function even(a) {
  return !(a % 2);
}

/**
 * Finds the first value in a list that satisfies a predicate function.
 *
 * @param {Function} p A predicate function.
 * @param {Array|String} as A list.
 * @returns An value in the list of `as` that satisfies the predicate function
 * `p`, or `undefined` if no value was found.
 *
 * @example
 *
 * F.find(F.gt(1), []) // undefined
 * F.find(F.gt(1), [1, 2, 3]) // 2
 *
 * F.find(F.eq('o'), '') // undefined
 * F.find(F.eq('o'), 'foo') // 'o'
 */

function find(p, as) {
  return head(filter(p, as));
}
var find$1 = curry(find);

/**
 * Finds the index of the first occurance of a value in a list that satisfies a
 * predicate function.
 *
 * @param {Function} p A predicate function.
 * @param {Array|String} as A list.
 * @returns {Number} The index of the first occurance of a value in the list of
 * `as` that satisfies the predicate function `p`,  or `undefined` if no value
 * was found.
 *
 * @example
 *
 * F.findIndex(F.gt(1), []) // undefined
 * F.findIndex(F.gt(1), [1, 2, 3]) // 1
 *
 * F.findIndex(F.eq('o'), '') // undefined
 * F.findIndex(F.eq('o'), 'foo') // 1
 */

function findIndex(p, as) {
  var n = as.length;

  for (var i = 0; i < n; i++) {
    if (p(as[i])) {
      return i;
    }
  }

  return undefined;
}
var findIndex$1 = curry(findIndex);

/**
 * Folds a list from right-to-left with a function.
 *
 * @param {Function} f A binary function.
 * @param s A starting value.
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the elements in the list of
 * `as` folded right-to-left with the binary function `f` and starting value
 * `s`.
 *
 * @example
 *
 * F.foldRight(F.append, [], [1, 2, 3]) // [3, 2, 1]
 * F.foldRight(F.append, '', 'foo') // 'oof'
 */

function foldRight(f, s, as) {
  return toArray(as).reduceRight(flip$1(f), s);
}
var foldRight$1 = curry(foldRight);

/**
 * Gets a property of an object.
 *
 * @param {String} k A key.
 * @param {Object} o An object.
 * @returns The property at the key `k` in the object `o`.
 *
 * @example
 *
 * var person = { name: 'Jane', age: 20, city: 'Melbourne' }
 * F.get('name', person) // 'Jane'
 */

function get(k, o) {
  return o[k];
}
var get$1 = curry(get);

/**
 * Gets a property of an object using a key path.
 *
 * @param {Array|String} ks A list or a string.
 * @param {Object} o An object.
 * @returns The property at the key path `ks` in the object `o`.
 *
 * @example
 *
 * var person = { name: 'Jane', age: 20, address: { city: 'Melbourne', country: 'Australia' } }
 * F.getIn(['address', 'city'], person) // 'Melbourne'
 * F.getIn('address.city', person) // 'Melbourne'
 */

function getIn(ks, o) {
  ks = isString(ks) ? ks.split('.') : ks;
  return ks.reduce(function (a, b) {
    return a !== undefined ? a[b] : undefined;
  }, o);
}
var getIn$1 = curry(getIn);

/**
 * Gets the last element in a list.
 *
 * @param {Array|String} as A list.
 * @returns The last element in the list of `as`, or `undefined` if the list is empty.
 *
 * @example
 *
 * F.last([1, 2, 3]) // 3
 * F.last('foo') // 'o'
 */
function last(as) {
  return as[as.length - 1];
}

/**
 * Gets the prefix of a list using a predicate function.
 *
 * @param {Function} p A predicate function.
 * @param {Array|String} as A list.
 * @returns {Array|String} The prefix of elements from the list of `as` while
 * the predicate function `p` is satisfied.
 *
 * @example
 *
 * F.takeWhile(F.lt(3), [1, 2, 3]) // [1, 2]
 * F.takeWhile(F.neq(o), 'foo') // 'f'
 */

function takeWhile(p, as) {
  var s = isString(as) ? '' : [];
  var n = as.length;

  for (var i = 0; i < n && p(as[i]); i++) {
    s = s.concat(as[i]);
  }

  return s;
}
var takeWhile$1 = curry(takeWhile);

/**
 * Splits a list using a predicate function.
 *
 * @param {Function} p A predicate function.
 * @param {Array|String} as A list.
 * @returns {Array} A list that contains the elements in the list of `as` split
 * into a pair of lists: a prefix of elements that satisfy the predicate
 * function `p` and the remainder of the list.
 *
 * @example
 *
 * F.span(F.lt(3), [1, 2, 3]) // [[1, 2], [3]]
 * F.span(F.neq(o), 'foo') // ['f', 'oo']
 */

function span(p, as) {
  return [takeWhile(p, as), dropWhile(p, as)];
}
var span$1 = curry(span);

/**
 * Groups the values in a list using a comparator function.
 *
 * The comparator function `f` compares two values, `a` and `b`. If the values
 * are both considered to be in the same group, then the comparator function
 * should return `true`. Otherwise it should return `false`.
 *
 * @param {Function} c A comparator function.
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the values in the list of `as`
 * grouped into sublists that satisfy the comparator function `c`.
 *
 * @example
 *
 * F.groupBy((a, b) => a === b, [1, 2, 2, 3, 3, 3]) // [[1], [2, 2], [3, 3, 3]]
 * F.groupBy((a, b) => a === b, 'Mississippi') // ['M', 'i', 'ss', 'i', 'ss', 'i', 'pp', 'i']
 */

function groupBy(c, as) {
  var b = head(as);
  var bs = span$1(function (a) {
    return c(a, b);
  }, tail(as));
  return empty(as) ? [] : prepend(prepend(b, head(bs)), groupBy(c, last(bs)));
}
var groupBy$1 = curry(groupBy);

/**
 * Groups the values in a list.
 *
 * This is a special case of the `groupBy` function where the values are compared
 * using the strict equality `===` operator.
 *
 * @function
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the values in the list of `as`
 * grouped into sublists of equal values.
 *
 * @example
 *
 * F.group([1, 2, 2, 3, 3, 3]) // [[1], [2, 2], [3, 3, 3]]
 * F.group('Mississippi') // ['M', 'i', 'ss', 'i', 'ss', 'i', 'pp', 'i']
 */

var group = groupBy$1(eq$1);

/**
 * Determines whether one number is greater than another.
 *
 * @param {Number} a The first number.
 * @param {Number} b The second number.
 * @returns {Boolean} `true` if the number `b` is greater than the number `a`,
 * false otherwise.
 */

function gt(a, b) {
  return b > a;
}
var gt$1 = curry(gt);

/**
 * Determines whether one number is greater than or equal to another.
 *
 * @param {Number} a The first number.
 * @param {Number} b The second number.
 * @returns {Boolean} `true` if the number `b` is greater than or euqal to the
 * number `a`, false otherwise.
 */

function gte(a, b) {
  return b >= a;
}
var gte$1 = curry(gte);

/**
 * Increments a number.
 *
 * @param {Number} a A number.
 * @returns {Number} The result of `a + 1`.
 */
function inc(a) {
  return a + 1;
}

/**
 * Gets the elements before the last element in a list.
 *
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the elements before the last
 * element in the list of `as`.
 *
 * @example
 *
 * F.init([1, 2, 3]) // [1, 2]
 * F.init('foo') // 'fo'
 */
function init(as) {
  return as.slice(0, as.length - 1);
}

/**
 * Gets all initial segments of a list.
 *
 * @param {Array|String} as A list.
 * @returns {Array} A list that contains all initial segments of the list of
 * `as`.
 *
 * @example
 *
 * F.inits([1, 2, 3]) // [[], [1], [1, 2], [1, 2, 3]]
 * F.inits('foo') // ['', 'f', 'fo', 'foo']
 */

function inits(as) {
  return prepend$1(mempty(as), empty(as) ? [] : inits(tail(as)).map(prepend$1(head(as))));
}

/**
 * Calculates the intersection of two lists.
 *
 * The comparator function `f` compares two elements, `a` and `b`. If the
 * elements are considered to be equal, then the comparator function should
 * return `true`. Otherwise it should return `false`.
 *
 * Duplicates are removed from `bs`, but if `as` contains duplicates then so
 * will the result.
 *
 * @param {Function} f A comparator function.
 * @param {Array|String} as A list.
 * @param {Array|String} bs A list.
 * @returns {Array|String} A list that contains the intersection of the elments
 * in the lists of `as` and `bs`.
 *
 * @example
 *
 * F.intersectBy((a, b) => a === b, [1, 2, 3], [2, 3, 4]) // [2, 3]
 * F.intersectBy((a, b) => a === b, 'hello', 'world') // 'ol'
 */

function intersectBy(f, as, bs) {
  return fold(function (cs, a) {
    return any(function (b) {
      return f(a, b);
    }, bs) ? append(a, cs) : cs;
  }, mempty(as), as);
}
var intersectBy$1 = curry(intersectBy);

/**
 * Calculates the intersection of two lists.
 *
 * This is a special case of the `intersectBy` function where the elements are
 * compared using the strict equality `===` operator.
 *
 * Duplicates are removed from `bs`, but if `as` contains duplicates then so
 * will the result.
 *
 * @function
 * @param {Array|String} as A list.
 * @param {Array|String} bs A list.
 * @returns {Array|String} A list that contains the intersection of the elments
 * in the lists of `as` and `bs`.
 *
 * @example
 *
 * F.intersect([1, 2, 3], [2, 3, 4]) // [2, 3]
 * F.intersect('hello', 'world') // 'ol'
 */

var intersect = intersectBy$1(eq$1);

/**
 * Intersperses the elements of a list with separator.
 *
 * @param {String} s A separator.
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the elements in the list of
 * `as` interspersed with the separator `s`.
 *
 * @example
 *
 * F.intersperse(4, [1, 2, 3]) // [1, 4, 2, 4, 3]
 * F.intersperse('-', 'foo') // 'f-o-o'
 */

function intersperse(s, as) {
  var prependToAll = function prependToAll(bs) {
    return empty(bs) ? mempty(bs) : concat(s, head(bs), prependToAll(tail(bs)));
  };

  return empty(as) ? mempty(as) : concat(head(as), prependToAll(tail(as)));
}
var intersperse$1 = curry(intersperse);

/**
 * Determines if a list is a prefix of another list.
 *
 * @param {Array|String} as A list.
 * @param {Array|String} bs A list.
 * @returns {Boolean} `true` if the list of `as` is a prefix of the list of
 * `bs`, `false` otherwise.
 *
 * @example
 *
 * F.isPrefixOf([], [1, 2, 3]) // true
 * F.isPrefixOf([1, 2], [1, 2, 3]) // true
 * F.isPrefixOf([2, 3], [1, 2, 3]) // false
 *
 * F.isPrefixOf('', 'foo') // true
 * F.isPrefixOf('fo', 'foo') // true
 * F.isPrefixOf('oo', 'foo') // false
 */

function isPrefixOf(as, bs) {
  if (empty(as)) {
    return true;
  } else if (empty(bs)) {
    return false;
  } else {
    return head(as) === head(bs) && isPrefixOf(tail(as), tail(bs));
  }
}
var isPrefixOf$1 = curry(isPrefixOf);

/**
 * Gets all final segments of a list.
 *
 * @param {Array|String} as A list.
 * @returns {Array} A list that contains all final segments of the list of
 * `as`.
 *
 * @example
 *
 * F.tails([1, 2, 3]) // [[1, 2, 3], [2, 3], [3], []]
 * F.tails('foo') // ['foo', 'oo', 'o', '']
 */

function tails(as) {
  return prepend(as, empty(as) ? [] : tails(tail(as)));
}

/**
 * Determines if a list is contained within another list.
 *
 * @param {Array|String} as A list.
 * @param {Array|String} bs A list.
 * @returns {Boolean} `true` if the list of `as` is contained within the list
 * of `bs`, `false` otherwise.
 *
 * @example
 *
 * F.isInfixOf([], [1, 2, 3]) // true
 * F.isInfixOf([2, 3], [1, 2, 3]) // true
 * F.isInfixOf([3, 2], [1, 2, 3]) // false
 *
 * F.isInfixOf('', 'foo') // true
 * F.isInfixOf('oo', 'foo') // true
 * F.isInfixOf('of', 'foo') // false
 */

function isInfixOf(as, bs) {
  return any(isPrefixOf$1(as), tails(bs));
}
var isInfixOf$1 = curry(isInfixOf);

/**
 * Reverses the elements in a list.
 *
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the elements in the list of
 * `as` in reverse order.
 *
 * @example
 *
 * F.reverse([1, 2, 3]) // [3, 2, 1]
 * F.reverse('foo') // 'oof'
 */

function reverse (as) {
  return toArray(as).reduce(flip$1(prepend$1), mempty(as));
}

/**
 * Determines if a list is a suffix of another list.
 *
 * @param {Array|String} as A list.
 * @param {Array|String} bs A list.
 * @returns {Boolean} `true` if the list of `as` is a suffix of the list of
 * `bs`, `false` otherwise.
 *
 * @example
 *
 * F.isSuffixOf([], [1, 2, 3]) // true
 * F.isSuffixOf([1, 2], [1, 2, 3]) // false
 * F.isSuffixOf([2, 3], [1, 2, 3]) // true
 *
 * F.isSuffixOf('', 'foo') // true
 * F.isSuffixOf('fo', 'foo') // false
 * F.isSuffixOf('oo', 'foo') // true
 */

function isSuffixOf(as, bs) {
  return isPrefixOf(reverse(as), reverse(bs));
}
var isSuffixOf$1 = curry(isSuffixOf);

/**
 * Gets the keys of an object.
 *
 * @param {Object} o An object.
 * @returns {Array} A list of keys for the properties of the object `o`.
 *
 * @example
 *
 * var person = { name: 'Jane', age: 20, city: 'Melbourne' }
 * F.keys(person) // ['name', 'age', 'city']
 */
function keys(o) {
  return Object.keys(o);
}

/**
 * Gets the length of a list.
 *
 * @param {Array|String} as A list.
 * @returns {Number} The number of elements in the list of `as`.
 *
 * @example
 *
 * F.length([1, 2, 3]) // 3
 * F.length('foo') // 3
 */
function length(as) {
  return as.length;
}

/**
 * Determines whether one number is less than another.
 *
 * @param {Number} a The first number.
 * @param {Number} b The second number.
 * @returns {Boolean} `true` if the number `b` is less than the number `a`,
 * false otherwise.
 */

function lt(a, b) {
  return b < a;
}
var lt$1 = curry(lt);

/**
 * Determines whether one number is less than or equal to another.
 *
 * @param {Number} a The first number.
 * @param {Number} b The second number.
 * @returns {Boolean} `true` if the number `b` is less than or equal to the
 * number `a`, false otherwise.
 */

function lte(a, b) {
  return b <= a;
}
var lte$1 = curry(lte);

/**
 * Calculates the maximum value of a list using a comparator function.
 *
 * The comparator function compares two elements, `a` and `b`. If `a` is
 * greater than `b`, then the comparator function should return `1`. If `a` is
 * less than `b`, then the comparator function should return `-1`. If both
 * elements are equal then, the comparator function should return `0`.
 *
 * @param {Function} f A comparator function.
 * @param {Array|String} as A list.
 * @returns The maximum value in the list of `as` using the comparator function
 * `f`.
 *
 * @example
 *
 * F.maximumBy(F.compare, [1, 2, 3]) // 3
 * F.maximumBy(F.compare, 'abc') // 'c'
 */

function maximumBy(f, as) {
  return fold(function (a, b) {
    return f(a, b) > 0 ? a : b;
  }, as[0], as);
}
var maximumBy$1 = curry(maximumBy);

/**
 * Calculates the maximum value of a list.
 *
 * This a special case of the `maximumBy` function where the values are
 * compared using natural ordering.
 *
 * @function
 * @param {Array|String} as A list.
 * @returns Returns the maximum value in the list of `as`.
 *
 * @example
 *
 * F.maximum([1, 2, 3]) // 3
 * F.maximum('abc') // 'c'
 */

var maximum = maximumBy$1(compare$1);

/**
 * Calculates the minimum value of a list using a comparator function.
 *
 * The comparator function compares two elements, `a` and `b`. If `a` is
 * greater than `b`, then the comparator function should return `1`. If `a` is
 * less than `b`, then the comparator function should return `-1`. If both
 * elements are equal, then the comparator function should return `0`.
 *
 * @param {Function} f A comparator function.
 * @param {Array|String} as A list.
 * @returns The minimum value in the list of `as` using the comparator function
 * `f`.
 *
 * @example
 *
 * F.minimumBy(F.compare, [1, 2, 3]) // 1
 * F.minimumBy(F.compare, 'abc') // 'a'
 */

function minimumBy(f, as) {
  return fold(function (a, b) {
    return f(a, b) < 0 ? a : b;
  }, as[0], as);
}
var minimumBy$1 = curry(minimumBy);

/**
 * Calculates the minimum value of a list.
 *
 * This a special case of the `minaximumBy` function where the values are
 * compared using natural ordering.
 *
 * @function
 * @param {Array|String} as A list.
 * @returns Returns the minimum value in the list of `as`.
 *
 * @example
 *
 * F.minimum([1, 2, 3]) // 1
 * F.minimum('abc') // 'a'
 */

var minimum = minimumBy$1(compare$1);

/**
 * Returns the modulo of two numbers.
 *
 * @param {Number} a The first number.
 * @param {Number} b The second number.
 * @returns {Number} The result of `b % a`.
 */

function mod(a, b) {
  return b % a;
}
var mod$1 = curry(mod);

/**
 * Returns the product of two numbers.
 *
 * @param {Number} a The first number.
 * @param {Number} b The second number.
 * @returns {Number} The result of `b * a`.
 */

function mul(a, b) {
  return b * a;
}
var mul$1 = curry(mul);

/**
 * Returns the negation of a number.
 *
 * @param {Number} a A number.
 * @returns {Number} The result.
 */
function negate(a) {
  return -a;
}

/**
 * Determines whether two values are not equal.
 *
 * @param a The first value.
 * @param b The second value.
 * @returns {Boolean} `true` if the value `a` is strictly not equal (`!==`) to
 * the value `b`, false otherwise.
 *
 * @example
 *
 * F.neq(1, 1) // false
 * F.neq(1, 2) // true
 */

function neq(a, b) {
  return b !== a;
}
var neq$1 = curry(neq);

/**
 * Returns the logical NOT of a value.
 *
 *
 * @example
 *
 * F.not(true) // false
 * F.not(false) // true
 *
 * @param a A value.
 * @returns {Boolean} `true` if `a` is not truthy, `false` otherwise.
 */
function not(a) {
  return !a;
}

/**
 * Determines whether a number is odd.
 *
 * @param {Number} a A number.
 * @returns {Boolean} `true` if the number `a` is odd, false otherwise.
 */
function odd(a) {
  return !!(a % 2);
}

/**
 * Sets a property of an object.
 *
 * @param {String} k A key.
 * @param v A value.
 * @param {Object} o An object.
 * @returns {Object} A copy of the object `o` with the property `k` set to the
 * value `v`.
 *
 * @example
 *
 * var person = { name: 'Jane', age: 20, city: 'Melbourne' }
 * F.set('name', 'Steve', person) // { name: 'Steve', age: 20, city: 'Melbourne' }
 */

function set(k, v, o) {
  var p = {};
  p[k] = v;
  return copy(o, p);
}
var set$1 = curry(set);

/**
 * Omits properties of an object.
 *
 * @param {Array} ks A list of keys.
 * @param {Object} o An object.
 * @returns {Object} A copy of the object `o` *without* the properties in the
 * list of `ks`.
 *
 * @example
 *
 * var person = { name: 'Jane', age: 20, city: 'Melbourne' }
 * F.omit(['name', 'age'], person) // { city: 'Melbourne' }
 */

function omit(ks, o) {
  return difference(keys(o), ks).reduce(function (p, k) {
    return set(k, get(k, o), p);
  }, {});
}
var omit$1 = curry(omit);

/**
 * Returns the logical OR of two values.
 *
 * @param a The first value.
 * @param b The second value.
 * @returns {Boolean} The result of `b || a`.
 *
 * @example
 *
 * F.or(false, true) // true
 * F.or(0, 1) // true
 * F.or('', 'foo') // true
 */

function or(a, b) {
  return !!(b || a);
}
var or$1 = curry(or);

/**
 * Gets the key-value pairs of an object.
 *
 * @param {Object} o An object.
 * @returns {Array} A list of key-value pairs for the properties of the object
 * `o`.
 *
 * @example
 *
 * var person = { name: 'Jane', age: 20, city: 'Melbourne' }
 * F.pairs(person) // [['name', 'Jane'], ['age', 20], ['city', 'Melbourne']]
 */

function pairs(o) {
  return keys(o).map(function (k) {
    return [k, get$1(k, o)];
  });
}

/**
 * Partitions a list using a predicate function.
 *
 * @param {Function} p A predicate function.
 * @param {Array|String} as A list.
 * @returns {Array} A list that contains the elements in the list of `as` split
 * into a pair of lists: the elements that satisfy the predicate function `p`
 * and the elements that do not satisfy the predicate function `p`.
 *
 * @example
 *
 * F.partition(F.gt(1), [1, 2, 3]) // [[2, 3], [1]]
 * F.partition(F.eq('o'), 'foo') // ['oo', 'f']
 */

function partition(p, as) {
  return [filter(p, as), filter(compose(not, p), as)];
}
var partition$1 = curry(partition);

/**
 * Calculates the permutations of a list.
 *
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains all the permutations of the
 * elements in the list of `as`.
 *
 * @example
 *
 * F.permutations([1, 2, 3]) // [[1, 2, 3], [2, 1, 3], [3, 2, 1], [2, 3, 1], [3, 1, 2], [1, 3, 2]]
 * F.permutations('abc') // ['abc', 'bac', 'cba', 'bca', 'cab', 'acb']
 */

function permutations(as) {
  var permutations_ = function permutations_(bs_, cs) {
    var b = head(bs_);
    var bs = tail(bs_);
    return empty(bs_) ? [] : foldRight(interleave, permutations_(bs, prepend$1(b, cs)), permutations(cs));

    function interleave(ds, r) {
      return interleave_(id, ds)[1];

      function interleave_(f, es_) {
        if (empty(es_)) {
          return [bs, r];
        } else {
          var e = head(es_);
          var es = tail(es_);
          var s = interleave_(compose(f, prepend$1(e)), es);
          return [prepend$1(e, s[0]), prepend$1(f(concat(b, e, s[0])), s[1])];
        }
      }
    }
  };

  return prepend$1(as, permutations_(as, []));
}

/**
 * Picks properties of an object.
 *
 * @param {Array} ks A list.
 * @param {Object} o An object.
 * @returns {Object} A copy of the object `o` *with* the properties in the list
 * of `ks`.
 *
 * @example
 *
 * var person = { name: 'Jane', age: 20, city: 'Melbourne' }
 * F.pick(['name', 'age'], person) // { name: 'Jane', age: 20 }
 */

function pick(ks, o) {
  return ks.reduce(function (p, k) {
    return set(k, get(k, o), p);
  }, {});
}
var pick$1 = curry(pick);

/**
 * Calculates the product of the elements in a list.
 *
 * @param {Array} as A list.
 * @returns {Number} The product of the elements in the list of `as`.
 *
 * @example
 *
 * F.product([1, 2, 3]) // 6
 */

function product(as) {
  return fold$1(mul$1, 1, as);
}

/**
 * Generates a random float.
 *
 * @param {Number} a A number.
 * @param {Number} b A number.
 * @returns {Number} A random float between `a` and `b`.
 */

function randomFloat(a, b) {
  return Math.random() * (b - a) + a;
}
var randomFloat$1 = curry(randomFloat);

/**
 * Generates a random integer.
 *
 * @param {Number} a A number.
 * @param {Number} b A number.
 * @returns {Number} A random integer between `a` and `b`.
 */

function randomInt(a, b) {
  return Math.floor(Math.random() * (b - a + 1)) + a;
}
var randomInt$1 = curry(randomInt);

/**
 * Creates a new array of numbers.
 *
 * @param {Number} a A number.
 * @param {Number} n A number.
 * @returns {Array} An array of numbers of length `n` starting from `a`.
 *
 * @example
 *
 * F.range(1, 3) // [1, 2, 3]
 */

function range(a, n) {
  return array(n).map(function (_, i) {
    return a + i;
  });
}
var range$1 = curry(range);

/**
 * Removes the first occurance of an element from a list.
 *
 * This is a special case of the `removeBy` function where the elements are
 * compared using the strict equality `===` operator.
 *
 * @function
 * @param a A value.
 * @param {Array|String} bs A list.
 * @returns {Array|String} A list with the first occurance of the element `a`
 * removed from the list of `bs`.
 *
 * @example
 *
 * F.remove(2, [1, 2, 3]) // [1, 3]
 * F.remove('f', 'foo') // 'oo'
 */

var remove = removeBy$1(eq$1);

/**
 * Replaces a term in a string.
 *
 * @param {String|RegExp} a A string or regular expression.
 * @param {String} b A string.
 * @param {String} s A string.
 * @returns {String} The result of replacing term `a` with the string `b` in
 * the string `s`.
 *
 * @example
 *
 * F.replace('r', 'z', 'bar') // baz
 * F.replace(/^hello/, 'goodbye', 'hello world!') // goodbye world!
 */

function replace(a, b, s) {
  return s.replace(a, b);
}
var replace$1 = curry(replace);

/**
 * Creates a new string.
 *
 * @param {Number} n The length of the string.
 * @returns {String} A string of length `n`.
 *
 * @example
 *
 * F.string(3) // '   '
 */

function string(n) {
  return array(n + 1).join(' ');
}

/**
 * Replicates a value.
 *
 * @param {Number} n A number.
 * @param a A value.
 * @returns {Array|String} A list of length `n` with `a` the value of every
 * element.
 *
 * @example
 *
 * F.replicate(3, 1) // [1, 1, 1]
 * F.replicate(3, 'a') // 'aaa'
 */

function replicate(n, a) {
  var as = isString(a) ? string(n) : array(n);
  return concatMap(function () {
    return [a];
  }, as);
}
var replicate$1 = curry(replicate);

/**
 * Shuffles a list using the [Fisher-Yates
 * algorithm](http://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
 *
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the elements in the list of
 * `as` randomly shuffled.
 *
 * @example
 *
 * F.shuffle([1, 2, 3]) // [2, 3, 1]
 * F.shuffle('abc') // 'bca'
 */

function shuffle(as) {
  var i = -1;

  var f = function f(b, a) {
    var j = randomInt$1(0, ++i);
    b[i] = b[j];
    b[j] = a;
    return b;
  };

  var r = array(as.length);
  var bs = fold(f, r, as);
  var s = isString(as) ? '' : [];
  return concatWith(s, bs);
}

/**
 * Takes a number of elements from the start of a list.
 *
 * @param {Number} n The number of elements to take.
 * @param {Array|String} as A list.
 * @returns {Array|String} The result after taking `n` elements from the list
 * of `as`.
 *
 * @example
 *
 * F.take(2, [1, 2, 3]) // [1, 2]
 * F.take(2, 'foo') // 'fo'
 */

function take(n, as) {
  var s = isString(as) ? '' : [];
  var m = as.length;

  for (var i = 0; i < Math.min(m, n); i++) {
    s = s.concat(as[i]);
  }

  return s;
}
var take$1 = curry(take);

/**
 * Samples random elements from a list.
 *
 * @param {Number} n The number of elements to sample.
 * @param {Array|String} as A list.
 * @returns {Array|String} A list of `n` elements randomly sampled from the
 * list of `as`.
 *
 * @example
 *
 * F.sample(2, [1, 2, 3]) // [3, 1]
 * F.sample(2, 'abc') // 'ca'
 */

function sample(n, as) {
  return take(n, shuffle(as));
}
var sample$1 = curry(sample);

/**
 * Applies the function `f` to the value `a` and returns the value `a`
 * unchanged.
 *
 * @param {Function} f A function.
 * @param a A value.
 * @returns The value `a`.
 *
 * @example
 *
 * function f (a) { console.log(a) }
 * F.tap(f)(1) // 1
 */

function tap(f, a) {
  f(a);
  return a;
}
var tap$1 = curry(tap);

/**
 * Scans a list from left-to-right with a function.
 *
 * @param {Function} f A binary function.
 * @param s A starting value.
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the elements in the list of
 * `as` scanned left-to-right with the binary function `f` and starting value
 * `s`.
 *
 * @example
 *
 * F.scan(F.flip(F.prepend), [],  [1, 2, 3]) // [[], [1], [2, 1], [3, 2, 1]]
 * F.scan(F.flip(F.prepend), '',  'foo') // ['', 'f', 'of', 'oof']
 */

function scan(f, s, as) {
  var r = [s];
  fold(function (b, a) {
    return tap(r.push.bind(r), f(b, a));
  }, s, as);
  return r;
}
var scan$1 = curry(scan);

/**
 * Scans a list from right-to-left with a function.
 *
 * @param {Function} f A binary function.
 * @param s A starting value.
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the elements in the list of
 * `as` scanned right-to-left with the binary function `f` and starting value
 * `s`.
 *
 * @example
 *
 * F.scanRight(F.append, [],  [1, 2, 3]) // [[3, 2, 1], [3, 2], [3], []]
 * F.scanRight(F.append, '',  'foo') // ['oof', 'oo', 'o', '']
 */

function scanRight(f, s, as) {
  var r = [s];
  foldRight(function (a, b) {
    return tap(r.unshift.bind(r), f(a, b));
  }, s, as);
  return r;
}
var scanRight$1 = curry(scanRight);

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/**
 * Converts the list of `as` to a list of type `t`.
 *
 * @private
 */
function toList(as, t) {
  return t === 'string' ? as.join('') : as;
}

/**
 * Sorts a list using a comparator function.
 *
 * The comparator function compares two elements, `a` and `b`. If `a` is
 * greater than `b`, then the comparator function should return `1`. If `a` is
 * less than `b`, then the comparator function should return `-1`. If both
 * elements are equal then, the comparator function should return `0`.
 *
 * @param {Function} c A comparator function.
 * @param {Array|String} as A list.
 * @returns {Array|String} A list that contains the elements in the list of
 * `as` sorted using the comparator function `c`.
 *
 * @example
 *
 * F.sortBy(F.compare, [2, 3, 1]) // [1, 2, 3]
 * F.sortBy(F.compare, 'bca') // 'abc'
 */

function sortBy(c, as) {
  var bs = toArray(as.slice(0));
  return toList(bs.sort(c), _typeof(as));
}
var sortBy$1 = curry(sortBy);

/**
 * Sorts a list using natural ordering.
 *
 * This a special case of the `sortBy` function where the values are compared
 * using natural ordering.
 *
 * @function
 * @param {Array|String} a A list.
 * @returns {Array|String} A list that contains the elements in the list of
 * `as` sorted.
 *
 * @example
 *
 * F.sort([2, 3, 1]) // [1, 2, 3]
 * F.sort('bca') // 'abc'
 */

var sort = sortBy$1(compare$1);

/**
 * Splits a list.
 *
 * @param {Number} n A number.
 * @param {Array|String} as A list.
 * @returns {Array} A list that contains the elements in the list of `as` split
 * into a pair of lists: a prefix of length `n` and the remainder of the list.
 *
 * @example
 *
 * F.splitAt(1, [1, 2, 3]) // [[1], [2, 3]]
 * F.splitAt(1, 'foo') // ['f', 'oo']
 */

function splitAt(n, as) {
  return [take(n, as), drop(n, as)];
}
var splitAt$1 = curry(splitAt);

/**
 * Returns the difference of two numbers.
 *
 * @param {Number} a The first number.
 * @param {Number} b The second number.
 * @returns {Number} The result of `b - a`.
 */

function sub(a, b) {
  return b - a;
}
var sub$1 = curry(sub);

/**
 * Returns `a` in a pure context.
 *
 * @private
 */

function pure(a) {
  return isString(a) || isArrayOfStrings(a) ? a : [a];
}

/**
 * Calculates the subsequences of a list.
 *
 * @param {Array|String} as A list.
 * @returns {Array} A list that contains all the subsequences of the elements
 * in the list of `as`.
 *
 * @example
 *
 * F.subsequences([1, 2, 3]) // [[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]
 * F.subsequences('abc') // ['', 'a', 'b', 'ab', 'c', 'ac', 'bc', 'abc']
 */

function subsequences(as) {
  var subsequences_ = function subsequences_(bs) {
    var b = head(bs);

    var f = function f(ys, r) {
      return concat(pure(ys), pure(prepend$1(b, ys)), r);
    };

    if (empty(bs)) {
      return [];
    } else {
      return prepend$1(pure(b), foldRight(f, [], subsequences_(tail(bs))));
    }
  };

  return prepend$1(mempty(as), subsequences_(as));
}

/**
 * Calculates the sum of the elements in a list.
 *
 * @param {Array} as A list.
 * @returns {Number} The sum of the elements in the list of `as`.
 *
 * @example
 *
 * F.sum([1, 2, 3]) // 6
 */

function sum(as) {
  return fold(add$1, 0, as);
}

/**
 * Surrounds the list of `cs` with the values `a` and `b`.
 *
 * @param a A value.
 * @param b A value.
 * @param {Array|String} cs A list.
 * @returns {Array|String} A new list.
 *
 * @example
 *
 * F.surround(0, 4, [1, 2, 3]) // [0, 1, 2, 3, 4]
 * F.surround('(', ')', 'foo') // '(foo)'
 */

function surround(a, b, cs) {
  return append(b, prepend(a, cs));
}
var surround$1 = curry(surround);

/**
 * Converts a string to lowercase.
 *
 * @param {String} s A string.
 * @returns {String} A new string.
 */
function toLower(s) {
  return s.toLowerCase();
}

/**
 * Converts a string to uppercase.
 *
 * @param {String} s A string.
 * @returns {String} A new string.
 */
function toUpper(s) {
  return s.toUpperCase();
}

/**
 * Converts a function of any arity to a unary function.
 *
 * @param {Function} f A function.
 * @returns {Function} A function that wraps the function `f` to accept only
 * one argument.
 *
 * @example
 *
 * function f (a) { ... }
 * const g = F.unary(f)
 * g(1, 2, 3) // f(1)
 */

function unary(f) {
  return f.length === 1 ? f : apply$1(f);
}

/**
 * Converts a binary function to a function on pairs.
 *
 * @param {Function} f A function.
 * @returns {Function} A function that wraps the binary function `f` to accept
 * a pair.
 *
 * @example
 *
 * var add = F.uncurry((a, b) => a + b)
 * add([1, 2]) // 3
 */

function uncurry(f, p) {
  return f(p[0], p[1]);
}
var uncurry$1 = curry(uncurry);

/**
 * Unzips a list of pairs into a pair of lists.
 *
 * @param {Array} as A list.
 * @returns {Array} The list of pairs `as` unzipped into a pair of lists.
 *
 * @example
 *
 * F.unzip([[1, 4], [2, 5], [3, 6]]) // [[1, 2, 3], [4, 5, 6]]
 * F.unzip([['f', 'b'], ['o', 'a'], ['o', 'r']]) // ['foo', 'bar']
 */

function unzip(as) {
  var s = mempty(as[0]);
  return as.reduceRight(function (p, ps) {
    var a = ps[0];
    var b = ps[1];
    var as = p[0];
    var bs = p[1];
    return [prepend(a, as), prepend(b, bs)];
  }, [s, s]);
}

/**
 * Calculates the union of two lists.
 *
 * The comparator function `f` compares two elements, `a` and `b`. If the
 * elements are both considered to equal, then the comparator function should
 * return `true`. Otherwise it should return `false`.
 *
 * Duplicates are removed from `bs`, but if `as` contains duplicates then so
 * will the result.
 *
 * @param {Function} f A comparator function.
 * @param {Array|String} as A list.
 * @param {Array|String} bs A list.
 * @returns {Array|String} A list that contains the union of elements in the
 * lists of `as` and `bs`.
 *
 * @example
 *
 * F.unionBy((a, b) => a === b, [1, 2, 3], [2, 3, 4]) // [1, 2, 3, 4]
 * F.unionBy((a, b) => a === b, 'hello', 'world') // 'hellowrd'
 */

function unionBy(f, as, bs) {
  return fold(function (cs, b) {
    return any(function (a) {
      return f(a, b);
    }, as) ? cs : append(b, cs);
  }, as, bs);
}
var unionBy$1 = curry(unionBy);

/**
 * Calculates the union of two lists.
 *
 * This is a special case of the `unionBy` function where the elements are
 * compared using the strict equality `===` operator.
 *
 * Duplicates are removed from `bs`, but if `as` contains duplicates then so
 * will the result.
 *
 * @function
 * @param {Array|String} as A list.
 * @param {Array|String} bs A list.
 * @returns {Array|String} A list that contains the union of elements in the
 * lists of `as` and `bs`.
 *
 * @example
 *
 * F.union([1, 2, 3], [2, 3, 4]) // [1, 2, 3, 4]
 * F.union('hello', 'world') // 'hellowrd'
 */

var union = unionBy$1(eq$1);

/**
 * Updates a property of an object with a function.
 *
 * @param {String} k A string.
 * @param {Function} f A function.
 * @param {Object} o An object.
 * @returns {Object} A copy of the object `o` with the property `k` updated
 * with the function `f`.
 *
 * @example
 *
 * var person = { name: 'Jane', age: 20, city: 'Melbourne' }
 * F.update('age', F.inc, person) // { name: 'Jane', age: 21, city: 'Melbourne' }
 */

function update(k, f, o) {
  return set(k, f(get(k, o)), o);
}
var update$1 = curry(update);

/**
 * Gets the values of an object.
 *
 * @param {Object} o An object.
 * @returns {Array} A list of values for the properties of the object `o`.
 *
 * @example
 *
 * var person = { name: 'Jane', age: 20, city: 'Melbourne' }
 * F.values(person) // ['Jane', 20, 'Melbourne']
 */

function values(o) {
  return keys(o).map(flip$1(get)(o));
}

/**
 * Determines whether all predicate functions in a list are satisfied when a
 * value is applied.
 *
 * @param {Array} ps A list of predicate functions.
 * @param a A value.
 * @returns {Boolean} `true` if all predicate functions in the list of `ps` are
 * satisfied when applied to the value `a`, `false` otherwise.
 *
 * @example
 *
 * var ps = [F.gt(1), F.gt(2)]
 * F.whereAll(ps, 1) // false
 * F.whereAll(ps, 2) // false
 * F.whereAll(ps, 3) // true
 */

function whereAll(ps, a) {
  return ps.map(applyRight$1(a)).reduce(and$1, true);
}
var whereAll$1 = curry(whereAll);

/**
 * Determines whether any predicate functions in a list are satisfied when a
 * value is applied.
 *
 * @param {Array} ps A list of predicate functions.
 * @param a A value.
 * @returns {Boolean} `true` if any predicate function in the list of `ps` are
 * satisfied when applied to the value `a`, `false` otherwise.
 *
 * @example
 *
 * var ps = [F.gt(1), F.gt(2)]
 * F.whereAny(ps, 1) // false
 * F.whereAny(ps, 2) // true
 * F.whereAny(ps, 3) // true
 */

function whereAny(ps, a) {
  return ps.map(applyRight$1(a)).reduce(or$1, false);
}
var whereAny$1 = curry(whereAny);

/**
 * Zips two lists with a function.
 *
 * @param {Function} f A binary function.
 * @param {Array|String} as A list.
 * @param {Array|String} bs A list.
 * @returns {Array} The lists of `as` and `bs` zipped with the binary function `f`.
 */

function zipWith(f, as, bs) {
  var n = Math.min(as.length, bs.length);
  return toArray(as.slice(0, n)).map(function (a, i) {
    return f(a, bs[i]);
  });
}
var zipWith$1 = curry(zipWith);

/**
 * Zips two lists into a list of pairs.
 *
 * This is a special case of the `zipWith` function where the elements are
 * combined using the `pair` function.
 *
 * @param {Array|String} as A list.
 * @param {Array|String} bs A list.
 * @returns {Array} The lists of `as` and `bs` zipped into a list of pairs.
 *
 * @example
 *
 * F.zip([1, 2, 3], [4, 5, 6]) // [[1, 4], [2, 5], [3, 6]]
 * F.zip('foo', 'bar') // [['f', 'b'], ['o', 'a'], ['o', 'r']]
 *
 */

function zip(as, bs) {
  return zipWith(pair, as, bs);
}
var zip$1 = curry(zip);

exports.add = add$1;
exports.all = all$1;
exports.always = always;
exports.and = and$1;
exports.any = any$1;
exports.append = append$1;
exports.apply = apply$1;
exports.apply2 = apply2$1;
exports.apply3 = apply3$1;
exports.applyMethod = applyMethod$1;
exports.applyMethod2 = applyMethod2$1;
exports.applyMethod3 = applyMethod3$1;
exports.applyRight = applyRight$1;
exports.array = array;
exports.between = between$1;
exports.binary = binary;
exports.branch = branch$1;
exports.cartesian = cartesian$1;
exports.clamp = clamp$1;
exports.compare = compare$1;
exports.compose = compose;
exports.concat = concat;
exports.concatMap = concatMap$1;
exports.copy = copy;
exports.curry = curry;
exports.dec = dec;
exports.difference = difference;
exports.differenceBy = differenceBy$1;
exports.div = div$1;
exports.drop = drop$1;
exports.dropWhile = dropWhile$1;
exports.elem = elem$1;
exports.elemIndex = elemIndex$1;
exports.elemIndices = elemIndices$1;
exports.empty = empty;
exports.eq = eq$1;
exports.even = even;
exports.filter = filter$1;
exports.find = find$1;
exports.findIndex = findIndex$1;
exports.findIndices = findIndices$1;
exports.flip = flip$1;
exports.fold = fold$1;
exports.foldRight = foldRight$1;
exports.get = get$1;
exports.getIn = getIn$1;
exports.group = group;
exports.groupBy = groupBy$1;
exports.gt = gt$1;
exports.gte = gte$1;
exports.head = head;
exports.id = id;
exports.inc = inc;
exports.init = init;
exports.inits = inits;
exports.intersect = intersect;
exports.intersectBy = intersectBy$1;
exports.intersperse = intersperse$1;
exports.isInfixOf = isInfixOf$1;
exports.isPrefixOf = isPrefixOf$1;
exports.isSuffixOf = isSuffixOf$1;
exports.keys = keys;
exports.last = last;
exports.length = length;
exports.lt = lt$1;
exports.lte = lte$1;
exports.map = map$1;
exports.max = max$1;
exports.maximum = maximum;
exports.maximumBy = maximumBy$1;
exports.min = min$1;
exports.minimum = minimum;
exports.minimumBy = minimumBy$1;
exports.mod = mod$1;
exports.mul = mul$1;
exports.negate = negate;
exports.neq = neq$1;
exports.not = not;
exports.nub = nub;
exports.nubBy = nubBy$1;
exports.odd = odd;
exports.omit = omit$1;
exports.or = or$1;
exports.pair = pair$1;
exports.pairs = pairs;
exports.partition = partition$1;
exports.permutations = permutations;
exports.pick = pick$1;
exports.prepend = prepend$1;
exports.product = product;
exports.randomFloat = randomFloat$1;
exports.randomInt = randomInt$1;
exports.range = range$1;
exports.remove = remove;
exports.removeBy = removeBy$1;
exports.replace = replace$1;
exports.replicate = replicate$1;
exports.reverse = reverse;
exports.sample = sample$1;
exports.scan = scan$1;
exports.scanRight = scanRight$1;
exports.set = set$1;
exports.shuffle = shuffle;
exports.sort = sort;
exports.sortBy = sortBy$1;
exports.span = span$1;
exports.splitAt = splitAt$1;
exports.string = string;
exports.sub = sub$1;
exports.subsequences = subsequences;
exports.sum = sum;
exports.surround = surround$1;
exports.tail = tail;
exports.tails = tails;
exports.take = take$1;
exports.takeWhile = takeWhile$1;
exports.tap = tap$1;
exports.toLower = toLower;
exports.toUpper = toUpper;
exports.unary = unary;
exports.uncurry = uncurry$1;
exports.unzip = unzip;
exports.union = union;
exports.unionBy = unionBy$1;
exports.update = update$1;
exports.values = values;
exports.variadic = variadic;
exports.whereAll = whereAll$1;
exports.whereAny = whereAny$1;
exports.zip = zip$1;
exports.zipWith = zipWith$1;
